import {
    type ComputedRef,
    computed,
    inject,
    onMounted,
    onUnmounted,
    provide,
    ref,
} from "vue";

/**
 * Summary Flow
You wrap a section of your app in <FMessageContext> to define a message boundary.
Inside this boundary, a component (like a message banner) uses useCurrentMessages() to listen for and display messages. This "subscribes" it to the context.
Another component in the same boundary (like a form button) uses useMessageHandler() to get the handler and calls postMessage().
Because the handler has a subscriber, it accepts the message and gives it to the display component. The message does not bubble up further.
If the display component were not present, the handler would have no subscribers, and it would pass the message to the next <FMessageContext> up the tree.

 */

/**
 * @internal
 * Symbol used for creating a branded type for message IDs.
 */
const idBrand = Symbol("Message ID brand");

/**
 * A unique identifier for a message.
 * This is a branded type to ensure that only IDs generated by `generateId` are used.
 */
export type MessageId = number & { [idBrand]: never };

let idCounter: number = 1;

/**
 * @internal
 * Generates a new unique MessageId.
 * @returns A new MessageId.
 */
function generateId(): MessageId {
    const id = idCounter++;
    return id as MessageId;
}

/**
 * Defines the possible types for a message, influencing its visual representation.
 */
export type MessageType = "warning" | "error" | "success" | "info";

/**
 * Represents a message to be displayed.
 * Data - The type of optional data that can be attached to the message.
 */
export interface Message<Data = unknown> {
    /** A unique identifier for the message. */
    id: MessageId;
    /** The heading/title of the message. */
    heading?: string;
    /** The main body content of the message. */
    body: string;
    /** The type of the message, e.g., 'error' or 'success'. */
    type: MessageType;
    /** Optional arbitrary data associated with the message. */
    data?: Data;
    /** Additional options for the message behavior. */
    options?: MessageOptions;
}

/**
 * Provides additional options for how a message should be handled.
 */
export interface MessageOptions {
    /** If true, the component displaying the message should scroll it into view. */
    scrollIntoView?: boolean;
}

/**
 * A function that receives a message. Used for listeners.
 */
export type MessageListener = (message: Message) => void;

/**
 * Handles messages for a specific context.
 */
export interface MessageHandler {
    /**
     * Posts a message to this MessageHandler.
     * The message propagates to the parent handler if this handler has no subscribers.
     * @param message - The message to be posted.
     * @returns The unique ID of the posted message.
     */
    postMessage: (message: Omit<Message, "id">) => MessageId;
    /**
     * Gets the current messages for this handler.
     * @returns The current messages, or null if there is none.
     */
    getMessages: () => Message[] | null;
    /**
     * Disposes the current message for this handler.
     */
    disposeMessage: (id?: MessageId) => void;
}

/**
 * @internal
 * A function that, when called, unsubscribes a listener.
 */
type Unsubscriber = () => void;

/**
 * @internal
 * Extends MessageHandler with internal methods for subscription management.
 */
type InternalMessageHandler = MessageHandler & {
    /**
     * Subscribes a component to messages from this handler.
     * @returns An unsubscriber function.
     */
    subscribe: () => Unsubscriber;
    /** A computed ref to the current message. */
    messages: ComputedRef<Message[] | null>;
    /**
     * Disposes a message by its ID.
     * @param id - The ID of the message to dispose.
     */
    disposeMessage: (id?: MessageId) => void;
};

let unhandledMessageListener: MessageListener = (message) => {
    const { stack } = new Error();
    // eslint-disable-next-line no-console -- Default listener just logs
    console.error("Unhandled message", message, stack);
};

/**
 * Sets a global listener for unhandled messages.
 * @param listener - The listener to be called for unhandled messages.
 */
export function setUnhandledMessageListener(listener: MessageListener): void {
    unhandledMessageListener = listener;
}

const handlers = new Map<MessageId, InternalMessageHandler>();

/**
 * Disposes a message with a specific ID, regardless of which MessageHandler it is in.
 * @param id - The ID of the message to dispose.
 */
export function disposeMessage(id: MessageId): void {
    handlers.get(id)?.disposeMessage(id);
}

/**
 * Disposes all messages in all MessageHandlers.
 */
export function disposeAllMessages(): void {
    // Call toArray to iterate over a copy of the values
    handlers
        .values()
        .toArray()
        .forEach((handler) => {
            handler.disposeMessage();
        });
}

const globalHandler = createMessageHandlerImpl(true);

const messageHandlerSymbol = Symbol("MessageHandler");

/**
 * @internal
 * Provides a MessageHandler to descendant components.
 * @param handler - The handler to provide.
 */
function provideHandler(handler: InternalMessageHandler): void {
    provide(messageHandlerSymbol, handler);
}

/**
 * @internal
 * Injects the nearest provided MessageHandler. Falls back to the global handler.
 * @returns The injected or global MessageHandler.
 */
function injectHandler(): InternalMessageHandler {
    return inject(messageHandlerSymbol, globalHandler);
}

/**
 * @internal
 * Creates and provides a new `MessageHandler` instance for a component and its children.
 * This is typically used within a component that defines a new message boundary.
 * @returns The created MessageHandler.
 */
export function createMessageHandler(): MessageHandler {
    const handler = createMessageHandlerImpl(false);
    provideHandler(handler);
    return handler;
}

/**
 * @internal
 * The core implementation for creating a message handler.
 * @param global - If true, creates a handler with no parent.
 * @returns An `InternalMessageHandler` instance.
 */
function createMessageHandlerImpl(global: boolean): InternalMessageHandler {
    const subscribers = new Set<symbol>();
    const parentHandler = global ? null : injectHandler();
    const internalMessages = ref<Message[]>([]);

    const handler: InternalMessageHandler = {
        postMessage(message: Omit<Message, "id">) {
            const id = generateId();
            const fullMessage: Message = { ...message, id };

            if (subscribers.size) {
                handlers.set(id, handler);
                internalMessages.value.push(fullMessage);
                if (internalMessages.value.length > 5) {
                    const oldestMessage = internalMessages.value.shift();
                    if (oldestMessage) {
                        handlers.delete(oldestMessage.id);
                    }
                }
                return id;
            } else if (parentHandler) {
                return parentHandler.postMessage(message);
            } else {
                unhandledMessageListener(fullMessage);
                return id;
            }
        },
        subscribe() {
            const key = Symbol("Message subscriber");
            subscribers.add(key);
            return () => subscribers.delete(key);
        },
        getMessages() {
            return internalMessages.value;
        },
        messages: computed(() => internalMessages.value),
        disposeMessage(id?: MessageId) {
            if (id === undefined) {
                for (const message of internalMessages.value) {
                    handlers.delete(message.id);
                }
                internalMessages.value = [];
            } else {
                const index = internalMessages.value.findIndex(
                    (m) => m.id === id,
                );
                if (index > -1) {
                    internalMessages.value.splice(index, 1);
                    handlers.delete(id);
                }
            }
        },
    };
    return handler;
}

/**
 * Returns the current `MessageHandler` from the Vue context.
 * This allows a component to programmatically post or dispose messages.
 * @returns The `MessageHandler` for the current context.
 */
export function useMessageHandler(): MessageHandler {
    return injectHandler();
}

/**
 * Subscribes to messages from the current `MessageHandler` and returns them as a computed ref.
 * The subscription is automatically managed within the component's lifecycle (onMounted/onUnmounted).
 * @returns A `ComputedRef` to the current messages, which will be `null` if there is no message.
 */
export function useCurrentMessages(): ComputedRef<Message[] | null> {
    const handler = injectHandler();
    let unsubscriber: Unsubscriber | undefined;
    onMounted(() => (unsubscriber = handler.subscribe()));
    onUnmounted(() => unsubscriber?.());
    return handler.messages;
}
